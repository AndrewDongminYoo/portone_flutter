<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, height=device-height, initial-scale=1, user-scalable=no"
    />
    <meta
      name="description"
      content="API docs for the build method from the PortonePaymentState class, for the Dart programming language."
    />
    <title>
      build method - PortonePaymentState class - portone_flutter_v2 library -
      Dart API
    </title>

    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto+Mono:ital,wght@0,300;0,400;0,500;0,700;1,400&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,400,0,0"
      rel="stylesheet"
    />

    <link rel="stylesheet" href="../../static-assets/github.css?v1" />
    <link rel="stylesheet" href="../../static-assets/styles.css?v1" />
    <link rel="icon" href="../../static-assets/favicon.png?v1" />
  </head>

  <body
    data-base-href="../../"
    data-using-base-href="false"
    class="light-theme"
  >
    <div id="overlay-under-drawer"></div>
    <header id="title">
      <span
        id="sidenav-left-toggle"
        class="material-symbols-outlined"
        role="button"
        tabindex="0"
        >menu</span
      >
      <ol class="breadcrumbs gt-separated dark hidden-xs">
        <li><a href="../../index.html">portone_flutter_v2</a></li>
        <li><a href="../../portone_flutter_v2">portone_flutter_v2.dart</a></li>
        <li>
          <a href="../../portone_flutter_v2/PortonePaymentState-class.html"
            >PortonePaymentState</a
          >
        </li>
        <li class="self-crumb">build method</li>
      </ol>
      <div class="self-name">build</div>
      <form class="search navbar-right" role="search">
        <input
          type="text"
          id="search-box"
          autocomplete="off"
          disabled
          class="form-control typeahead"
          placeholder="Loading search..."
        />
      </form>
      <div class="toggle" id="theme-button" title="Toggle brightness">
        <label for="theme">
          <input type="checkbox" id="theme" value="light-theme" />
          <span id="dark-theme-button" class="material-symbols-outlined">
            dark_mode
          </span>
          <span id="light-theme-button" class="material-symbols-outlined">
            light_mode
          </span>
        </label>
      </div>
    </header>
    <main>
      <div
        id="dartdoc-main-content"
        class="main-content"
        data-above-sidebar="portone_flutter_v2&#47;PortonePaymentState-class-sidebar.html"
        data-below-sidebar=""
      >
        <div>
          <h1><span class="kind-method">build</span> method</h1>
        </div>

        <section class="multi-line-signature">
          <div>
            <ol class="annotation-list">
              <li>
                @<a
                  href="https://api.flutter.dev/flutter/dart-core/override-constant.html"
                  >override</a
                >
              </li>
            </ol>
          </div>
          <span class="returntype"
            ><a href="https://api.flutter.dev/flutter/widgets/Widget-class.html"
              >Widget</a
            ></span
          >
          <span class="name">build</span>(<wbr />
          <ol class="parameter-list single-line">
            <li>
              <span class="parameter" id="build-param-context"
                ><span class="type-annotation"
                  ><a
                    href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html"
                    >BuildContext</a
                  ></span
                >
                <span class="parameter-name">context</span></span
              >
            </li>
          </ol>
          )

          <div class="features"><span class="feature">override</span></div>
        </section>

        <section class="desc markdown">
          <p>
            Describes the part of the user interface represented by this widget.
          </p>
          <p>
            The framework calls this method in a number of different situations.
            For example:
          </p>
          <ul>
            <li>
              After calling
              <a
                href="../../portone_flutter_v2/PortonePaymentState/initState.html"
                >initState</a
              >.
            </li>
            <li>
              After calling
              <a
                href="https://api.flutter.dev/flutter/widgets/State/didUpdateWidget.html"
                >didUpdateWidget</a
              >.
            </li>
            <li>
              After receiving a call to
              <a
                href="https://api.flutter.dev/flutter/widgets/State/setState.html"
                >setState</a
              >.
            </li>
            <li>
              After a dependency of this
              <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
                >State</a
              >
              object changes (e.g., an
              <a
                href="https://api.flutter.dev/flutter/widgets/InheritedWidget-class.html"
                >InheritedWidget</a
              >
              referenced by the previous
              <a href="../../portone_flutter_v2/PortonePaymentState/build.html"
                >build</a
              >
              changes).
            </li>
            <li>
              After calling
              <a
                href="https://api.flutter.dev/flutter/widgets/State/deactivate.html"
                >deactivate</a
              >
              and then reinserting the
              <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
                >State</a
              >
              object into the tree at another location.
            </li>
          </ul>
          <p>
            This method can potentially be called in every frame and should not
            have any side effects beyond building a widget.
          </p>
          <p>
            The framework replaces the subtree below this widget with the widget
            returned by this method, either by updating the existing subtree or
            by removing the subtree and inflating a new subtree, depending on
            whether the widget returned by this method can update the root of
            the existing subtree, as determined by calling
            <a
              href="https://api.flutter.dev/flutter/widgets/Widget/canUpdate.html"
              >Widget.canUpdate</a
            >.
          </p>
          <p>
            Typically implementations return a newly created constellation of
            widgets that are configured with information from this widget's
            constructor, the given
            <a
              href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html"
              >BuildContext</a
            >, and the internal state of this
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >
            object.
          </p>
          <p>
            The given
            <a
              href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html"
              >BuildContext</a
            >
            contains information about the location in the tree at which this
            widget is being built. For example, the context provides the set of
            inherited widgets for this location in the tree. The
            <a
              href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html"
              >BuildContext</a
            >
            argument is always the same as the <code>context</code> property of
            this
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >
            object and will remain the same for the lifetime of this object. The
            <a
              href="https://api.flutter.dev/flutter/widgets/BuildContext-class.html"
              >BuildContext</a
            >
            argument is provided redundantly here so that this method matches
            the signature for a
            <a href="https://api.flutter.dev/flutter/widgets/WidgetBuilder.html"
              >WidgetBuilder</a
            >.
          </p>
          <h2 id="design-discussion">Design discussion</h2>
          <h3 id="why-is-the-build-method-on-state-and-not-statefulwidget">
            Why is the
            <a href="../../portone_flutter_v2/PortonePaymentState/build.html"
              >build</a
            >
            method on
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >, and not
            <a
              href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"
              >StatefulWidget</a
            >?
          </h3>
          <p>
            Putting a <code>Widget build(BuildContext context)</code> method on
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >
            rather than putting a
            <code>Widget build(BuildContext context, State state)</code> method
            on
            <a
              href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"
              >StatefulWidget</a
            >
            gives developers more flexibility when subclassing
            <a
              href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"
              >StatefulWidget</a
            >.
          </p>
          <p>
            For example,
            <a
              href="https://api.flutter.dev/flutter/widgets/AnimatedWidget-class.html"
              >AnimatedWidget</a
            >
            is a subclass of
            <a
              href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"
              >StatefulWidget</a
            >
            that introduces an abstract
            <code>Widget build(BuildContext context)</code> method for its
            subclasses to implement. If
            <a
              href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"
              >StatefulWidget</a
            >
            already had a
            <a href="../../portone_flutter_v2/PortonePaymentState/build.html"
              >build</a
            >
            method that took a
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >
            argument,
            <a
              href="https://api.flutter.dev/flutter/widgets/AnimatedWidget-class.html"
              >AnimatedWidget</a
            >
            would be forced to provide its
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >
            object to subclasses even though its
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >
            object is an internal implementation detail of
            <a
              href="https://api.flutter.dev/flutter/widgets/AnimatedWidget-class.html"
              >AnimatedWidget</a
            >.
          </p>
          <p>
            Conceptually,
            <a
              href="https://api.flutter.dev/flutter/widgets/StatelessWidget-class.html"
              >StatelessWidget</a
            >
            could also be implemented as a subclass of
            <a
              href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"
              >StatefulWidget</a
            >
            in a similar manner. If the
            <a href="../../portone_flutter_v2/PortonePaymentState/build.html"
              >build</a
            >
            method were on
            <a
              href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"
              >StatefulWidget</a
            >
            rather than
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >, that would not be possible anymore.
          </p>
          <p>
            Putting the
            <a href="../../portone_flutter_v2/PortonePaymentState/build.html"
              >build</a
            >
            function on
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >
            rather than
            <a
              href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"
              >StatefulWidget</a
            >
            also helps avoid a category of bugs related to closures implicitly
            capturing <code>this</code>. If you defined a closure in a
            <a href="../../portone_flutter_v2/PortonePaymentState/build.html"
              >build</a
            >
            function on a
            <a
              href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"
              >StatefulWidget</a
            >, that closure would implicitly capture <code>this</code>, which is
            the current widget instance, and would have the (immutable) fields
            of that instance in scope:
          </p>
          <pre
            class="language-dart"
          ><code class="language-dart">// (this is not valid Flutter code)
class MyButton extends StatefulWidgetX {
  MyButton({super.key, required this.color});

  final Color color;

  @override
  Widget build(BuildContext context, State state) {
    return SpecialWidget(
      handler: () { print('color: $color'); },
    );
  }
}
</code></pre>
          <p>
            For example, suppose the parent builds <code>MyButton</code> with
            <code>color</code> being blue, the <code>$color</code> in the print
            function refers to blue, as expected. Now, suppose the parent
            rebuilds <code>MyButton</code> with green. The closure created by
            the first build still implicitly refers to the original widget and
            the <code>$color</code> still prints blue even through the widget
            has been updated to green; should that closure outlive its widget,
            it would print outdated information.
          </p>
          <p>
            In contrast, with the
            <a href="../../portone_flutter_v2/PortonePaymentState/build.html"
              >build</a
            >
            function on the
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >
            object, closures created during
            <a href="../../portone_flutter_v2/PortonePaymentState/build.html"
              >build</a
            >
            implicitly capture the
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >
            instance instead of the widget instance:
          </p>
          <pre
            class="language-dart"
          ><code class="language-dart">class MyButton extends StatefulWidget {
  const MyButton({super.key, this.color = Colors.teal});

  final Color color;
  // ...
}

class MyButtonState extends State&lt;MyButton&gt; {
  // ...
  @override
  Widget build(BuildContext context) {
    return SpecialWidget(
      handler: () { print('color: ${widget.color}'); },
    );
  }
}
</code></pre>
          <p>
            Now when the parent rebuilds <code>MyButton</code> with green, the
            closure created by the first build still refers to
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >
            object, which is preserved across rebuilds, but the framework has
            updated that
            <a href="https://api.flutter.dev/flutter/widgets/State-class.html"
              >State</a
            >
            object's
            <a href="https://api.flutter.dev/flutter/widgets/State/widget.html"
              >widget</a
            >
            property to refer to the new <code>MyButton</code> instance and
            <code>${widget.color}</code> prints green, as expected.
          </p>
          <p>See also:</p>
          <ul>
            <li>
              <a
                href="https://api.flutter.dev/flutter/widgets/StatefulWidget-class.html"
                >StatefulWidget</a
              >, which contains the discussion on performance considerations.
            </li>
          </ul>
        </section>

        <section class="summary source-code" id="source">
          <h2><span>Implementation</span></h2>
          <pre class="language-dart"><code class="language-dart">@override
Widget build(BuildContext context) {
  widget.logger(jsonEncode(widget.data.toJson()));
  final appScheme = widget.data.appScheme;
  final paymentData = widget.data.toJson();

  &#47;&#47; redirectUrl 이 비어있으면 기본값 설정
  if (paymentData[&#39;redirectUrl&#39;] == null) {
    paymentData[&#39;redirectUrl&#39;] = &#39;$appScheme:&#47;&#47;portone&#39;;
  }

  &#47;&#47; Tosspayments를 통한 TossPay에서만 발생하는 오류 (https:&#47;&#47;docs-pay.toss.im&#47;reference&#47;billing&#47;create#요청-파라미터)
  paymentData[&#39;retAppScheme&#39;] = &#39;$appScheme:&#47;&#47;portone&#39;;

  final html = &#39;&#39;&#39;
&lt;!doctype html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; &#47;&gt;
  &lt;script src=&quot;https:&#47;&#47;cdn.portone.io&#47;v2&#47;browser-sdk.js&quot;&gt;&lt;&#47;script&gt;
  &lt;script&gt;
    window.addEventListener(&quot;flutterInAppWebViewPlatformReady&quot;, () =&gt; {
      PortOne.requestPayment(${jsonEncode(paymentData)}).catch((err) =&gt;
        window.flutter_inappwebview.callHandler(&quot;$handlerName&quot;, err.message),
      );
    });
  &lt;&#47;script&gt;
&lt;&#47;head&gt;
&lt;body&gt;&lt;&#47;body&gt;
&lt;&#47;html&gt;

&#39;&#39;&#39;;

  return Scaffold(
    appBar: widget.appBar,
    body: PopScope(
      canPop: false,
      onPopInvokedWithResult: (bool didPop, Object? result) async {
        if (!mounted) return;
        if (controller != null &amp;&amp; await controller!.canGoBack()) {
          await controller!.goBack();
        } else {
          SchedulerBinding.instance.addPostFrameCallback((_) {
            if (mounted &amp;&amp; Navigator.of(context).canPop()) {
              Navigator.of(context).pop();
            }
          });
        }
      },
      child: SafeArea(
        child: IndexedStack(
          index: _stackIndex,
          children: [
            widget.initialChild ?? Container(),
            InAppWebView(
              gestureRecognizers: widget.gestureRecognizers,
              initialSettings: InAppWebViewSettings(
                useShouldOverrideUrlLoading: true,
                resourceCustomSchemes: [&#39;intent&#39;],
              ),
              onWebViewCreated: (InAppWebViewController created) async {
                controller = created;
                controller!.addJavaScriptHandler(
                  handlerName: handlerName,
                  callback: (List&lt;dynamic&gt; data) async {
                    widget.logger(&#39;PortOne SDK ERROR: $data&#39;);
                    widget.logger(&#39;PortOne SDK Error type: ${data.first.runtimeType}&#39;);
                    try {
                      widget.onError(data.first as Object?);
                    } catch (error, stackTrace) {
                      widget.logger(&#39;Error Occurred&#39;, error: error, stackTrace: stackTrace);
                      widget.onError(error);
                    }
                  },
                );
                await controller!.loadData(
                  mimeType: contentType,
                  data: html,
                  baseUrl: WebUri(&#39;https:&#47;&#47;flutter-sdk-content.portone.io&#47;&#39;),
                );
              },
              onLoadResourceWithCustomScheme: (InAppWebViewController controller, WebResourceRequest resource) async {
                return CustomSchemeResponse(contentType: contentType, data: Uint8List(0));
              },
              onLoadStop: (controller, Uri? url) async {
                if (mounted) {
                  setState(() {
                    _stackIndex = 1;
                  });
                }
              },
              shouldOverrideUrlLoading: (InAppWebViewController controller, NavigationAction navigateAction) async {
                final url = navigateAction.request.url;
                widget.logger(&#39;Navigation action request uri: ${url!.uriValue}&#39;);

                if (url.uriValue.scheme == &#39;http&#39; || url.uriValue.scheme == &#39;https&#39;) {
                  return NavigationActionPolicy.ALLOW;
                } else if (url.uriValue.scheme == appScheme) {
                  try {
                    final paymentResponse = PaymentResponse.fromJson(url.queryParameters);
                    widget.callback(paymentResponse);
                  } catch (exception, stackTrace) {
                    widget.logger(&#39;Error Occurred&#39;, error: exception, stackTrace: stackTrace);
                    widget.onError(exception);
                  }
                  return NavigationActionPolicy.CANCEL;
                } else if (url.uriValue.scheme == &#39;intent&#39;) {
                  try {
                    &#47;&#47; Retrieve the raw URL string.
                    final rawUri = url.rawValue;
                    &#47;&#47; Split the URL using &#39;#&#39; as the delimiter (e.g., &quot;intent:&#47;&#47;...&quot; and &quot;Intent;scheme=...;end&quot;).
                    final parts = rawUri.split(&#39;#&#39;);
                    if (parts.length != 2) {
                      throw const FormatException(&#39;Invalid intent URL format: missing fragment&#39;);
                    }
                    final baseUriStr = parts[0]; &#47;&#47; e.g., &quot;intent:&#47;&#47;some_path&quot;
                    final fragment = parts[1]; &#47;&#47; e.g., &quot;Intent;scheme=https;package=com.example;end&quot;

                    &#47;&#47; Remove the &quot;Intent;&quot; prefix if present.
                    var fragmentContent = fragment;
                    const intentPrefix = &#39;Intent;&#39;;
                    if (fragmentContent.startsWith(intentPrefix)) {
                      fragmentContent = fragmentContent.substring(intentPrefix.length);
                    }

                    &#47;&#47; Split each parameter using &#39;;&#39; as delimiter and create key-value pairs.
                    final paramsList = fragmentContent.split(&#39;;&#39;);
                    final params = &lt;String, String&gt;{};
                    for (final param in paramsList) {
                      if (param.isNotEmpty &amp;&amp; param.contains(&#39;=&#39;)) {
                        final keyValue = param.split(&#39;=&#39;);
                        params[keyValue[0]] = keyValue[1];
                      }
                    }

                    &#47;&#47; Extract the required &#39;scheme&#39; parameter.
                    final redirectScheme = params[&#39;scheme&#39;];
                    if (redirectScheme == null) {
                      throw const FormatException(&#39;Scheme parameter not found in intent URL&#39;);
                    }

                    &#47;&#47; Safely parse the base URI and replace its scheme.
                    final baseUri = Uri.parse(baseUriStr);
                    final redirectUri = baseUri.replace(scheme: redirectScheme);

                    &#47;&#47; Validate and launch the redirection URI.
                    if (await canLaunchUrl(redirectUri)) {
                      await launchUrl(redirectUri);
                    }
                  } catch (error, stackTrace) {
                    widget.logger(&#39;Intent URL parsing error&#39;, error: error, stackTrace: stackTrace);
                    widget.onError(error);
                  }
                  return NavigationActionPolicy.CANCEL;
                } else {
                  if (await canLaunchUrl(url.uriValue)) {
                    await launchUrl(url.uriValue);
                  }
                  return NavigationActionPolicy.CANCEL;
                }
              },
            ),
          ],
        ),
      ),
    ),
  );
}</code></pre>
        </section>
      </div>
      <!-- /.main-content -->
      <div id="dartdoc-sidebar-left" class="sidebar sidebar-offcanvas-left">
        <!-- The search input and breadcrumbs below are only responsively visible at low resolutions. -->
        <header id="header-search-sidebar" class="hidden-l">
          <form class="search-sidebar" role="search">
            <input
              type="text"
              id="search-sidebar"
              autocomplete="off"
              disabled
              class="form-control typeahead"
              placeholder="Loading search..."
            />
          </form>
        </header>
        <ol class="breadcrumbs gt-separated dark hidden-l" id="sidebar-nav">
          <li><a href="../../index.html">portone_flutter_v2</a></li>
          <li><a href="../../portone_flutter_v2">portone_flutter_v2</a></li>
          <li>
            <a href="../../portone_flutter_v2/PortonePaymentState-class.html"
              >PortonePaymentState</a
            >
          </li>
          <li class="self-crumb">build method</li>
        </ol>

        <h5>PortonePaymentState class</h5>
        <div id="dartdoc-sidebar-left-content"></div>
      </div>
      <!--/.sidebar-offcanvas-->
      <div
        id="dartdoc-sidebar-right"
        class="sidebar sidebar-offcanvas-right"
      ></div>
      <!--/.sidebar-offcanvas-->
    </main>
    <footer>
      <span class="no-break"> portone_flutter_v2 1.0.2 </span>
    </footer>

    <script src="../../static-assets/highlight.pack.js?v1"></script>
    <script src="../../static-assets/docs.dart.js"></script>
  </body>
</html>
